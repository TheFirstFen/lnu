package com.sb224sc.rubik.model;

import javafx.scene.transform.Rotate;
import javafx.geometry.Point3D;

import java.security.SecureRandom;

public class Move {
    public static class Wrapper {
        private int axis;
        private int pos;
        private int dir;

        public Wrapper(int a, int p, int d) {
            this.axis = a;
            this.pos = p;
            this.dir = d;
        }

        /**
         * Returns a new Wrapper object with the opposite direction.
         *
         * @return A new Wrapper object with the opposite direction.
         */
        public Wrapper opposite() {
            return new Wrapper(this.axis, this.pos, -this.dir);
        }
    }

    public static volatile boolean animating = false;
    protected static final String[] MOVES = new String[] { "F", "f", "R", "r", "U", "u", "L", "l", "B", "b", "D", "d" };
    public static final String CAPS = "FRULBDMESY";
    public static boolean animation = true;
    public static String currentMove;

    /**
     * Generates a string by modifying the input string based on specific rules.
     *
     * @param input The input string to be processed.
     * @return The modified string generated by the function.
     */
    public static String printAlgorithm(String input) {
        if (input == null)
            return null;
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);
            if (Character.isLowerCase(c)) {
                builder.append(Character.toUpperCase(c) + "'");
            } else {
                builder.append(Character.toString(c));
            }
            if (i != input.length() - 1) {
                char next = input.charAt(i + 1);
                if (next == c) {
                    builder.append("2 ");
                    i++;
                } else {
                    builder.append(" ");
                }
            } else {
                builder.append(" ");
            }
        }
        return builder.toString();
    }

    /**
     * Parses the given input string and returns the parsed output.
     *
     * @param input the input string to be parsed
     * @return the parsed output string
     */
    public static String parseNotation(String input) {
        input = input.toUpperCase();
        if (input.length() == 0)
            return null;
        StringBuilder output = new StringBuilder();
        for (int count = 0; count < input.toCharArray().length; count++) {
            String m = Character.toString(input.toCharArray()[count]);
            if (count + 1 < input.length()) {
                String after = Character.toString(input.charAt(count + 1));
                if (after.equals("'")) {
                    if (CAPS.contains(m)) {
                        output.append(m.toLowerCase());
                        // check number
                        if (count + 2 < input.length()
                                && ("23456789".contains(Character.toString(input.charAt(count + 2))))) {
                            output.append(m.toLowerCase()
                                    .repeat(Integer.parseInt(Character.toString(input.charAt(count + 2))) - 1));
                            count++;

                        }
                        count++;
                    } else {
                        return null;
                    }
                } else if ("23456789".contains(after)) {
                    int repeat = Integer.parseInt(after);
                    output.append(m.repeat(repeat));
                    count++;
                } else {
                    if (CAPS.contains(m)) {
                        output.append(m);
                    } else {
                        return null;
                    }
                }
            } else {
                if (CAPS.contains(m)) {
                    output.append(m);
                } else {
                    return null;
                }
            }
        }
        return output.toString();
    }

    /**
     * Moves a cube in a generic way based on the provided wrapper object.
     *
     * @param wrapper the wrapper object containing information about the move
     * @param cube    the cube to be moved
     */
    public static void genericMove(Wrapper wrapper, Cube cube) {
        if (animating)
            return;
        animating = true;
        switch (wrapper.axis) {
            case 0:
                cube.rotateX(wrapper.pos, wrapper.dir, animation);
                break;
            case 1:
                cube.rotateY(wrapper.pos, wrapper.dir, animation);
                break;
            case 2:
                cube.rotateZ(wrapper.pos, wrapper.dir, animation);
                break;
            default:
                break;
        }
    }

    /**
     * Generates a random move for the cube.
     *
     * @param rnd  the secure random generator
     * @param cube the cube object
     * @return the wrapper object containing the random move
     */
    public static Wrapper randomMove(SecureRandom rnd, Cube cube) {
        Wrapper wrapper = new Wrapper(rnd.nextInt(3),
                Cube.cubeSize == 3 ? (rnd.nextBoolean() ? 0 : 2) : rnd.nextInt(Cube.cubeSize),
                rnd.nextInt(2) == 0 ? 1 : -1);
        genericMove(wrapper, cube);
        return wrapper;
    }

    /**
     * Apply the given move to the Rubik's Cube.
     *
     * @param move the move to be applied
     * @param cube the Rubik's Cube object
     */
    public static void applyMove(String move, Cube cube) {
        currentMove = move;
        move = getRotationDirection(move, cube.posY, Rotate.Y_AXIS);

        if (move == null) {
            return;
        }

        switch (move) {
            case "F":
                frontClockwise(cube);
                break;
            case "f":
                frontCounterClockwise(cube);
                break;
            case "R":
                rightClockwise(cube);
                break;
            case "r":
                rightCounterClockwise(cube);
                break;
            case "U":
                upClockwise(cube);
                break;
            case "u":
                upCounterClockwise(cube);
                break;
            case "L":
                leftClockwise(cube);
                break;
            case "l":
                leftCounterClockwise(cube);
                break;
            case "B":
                backClockwise(cube);
                break;
            case "b":
                backCounterClockwise(cube);
                break;
            case "D":
                downClockwise(cube);
                break;
            case "d":
                downCounterClockwise(cube);
                break;
            case "M":
                middleClockwise(cube);
                break;
            case "m":
                middleCounterClockwise(cube);
                break;
            case "E":
                equatorClockwise(cube);
                break;
            case "e":
                equatorCounterClockwise(cube);
                break;
            case "S":
                standingClockwise(cube);
                break;
            case "s":
                standingCounterClockwise(cube);
                break;
            default:
                System.out.println("Invalid move: " + move);
        }
    }

    /**
     * Get the cube move when it gets rotated.
     * 
     * @param move   Cube move to transform, such as F or l. @link{Move.MOVES}
     * @param amount how much the cube gets rotated
     * @param axis   Rotation axis
     * @return The rotated move or <code>null</code> if the axis is invalid
     */
    public static String getRotationDirection(String move, int amount, Point3D axis) {
        String[] xMoves;
        String[] yMoves;
        String[] zMoves;

        switch (move.toUpperCase()) {
            case "F":
                xMoves = new String[] { "U", "B", "D" };
                yMoves = new String[] { "R", "B", "L" };
                zMoves = new String[] { "F", "F", "F" };
                break;
            case "R":
                xMoves = new String[] { "R", "R", "R" };
                yMoves = new String[] { "B", "L", "F" };
                zMoves = new String[] { "D", "L", "U" };
                break;
            case "U":
                xMoves = new String[] { "F", "D", "B" };
                yMoves = new String[] { "U", "U", "U" };
                zMoves = new String[] { "R", "D", "L" };
                break;
            case "L":
                xMoves = new String[] { "L", "L", "L" };
                yMoves = new String[] { "F", "R", "B" };
                zMoves = new String[] { "U", "R", "D" };
                break;
            case "B":
                xMoves = new String[] { "U", "F", "D" };
                yMoves = new String[] { "L", "F", "R" };
                zMoves = new String[] { "B", "B", "B" };
                break;
            case "D":
                xMoves = new String[] { "B", "U", "F" };
                yMoves = new String[] { "D", "D", "D" };
                zMoves = new String[] { "L", "U", "R" };
                break;
            case "M":
                xMoves = new String[] { "M", "M", "M" };
                yMoves = new String[] { "S", "m", "s" };
                zMoves = new String[] { "e", "m", "E" };
                break;
            case "E":
                xMoves = new String[] { "s", "e", "S" };
                yMoves = new String[] { "E", "E", "E" };
                zMoves = new String[] { "M", "d", "m" };
                break;
            case "S":
                xMoves = new String[] { "E", "s", "e" };
                yMoves = new String[] { "M", "s", "m" };
                zMoves = new String[] { "S", "S", "S" };
                break;
            default:
                return null;
        }

        if (amount > 3) {
            amount %= 4;
        }

        if (amount == 0)
            return move;

        boolean upper = CAPS.contains(move);

        if (Math.abs(axis.getX()) == Rotate.X_AXIS.getX()) {
            return upper ? xMoves[amount - 1]
                    : (CAPS.contains(xMoves[amount - 1]) ? xMoves[amount - 1].toLowerCase()
                            : xMoves[amount - 1].toUpperCase());
        } else if (Math.abs(axis.getY()) == Rotate.Y_AXIS.getY()) {
            return upper ? yMoves[amount - 1]
                    : (CAPS.contains(yMoves[amount - 1]) ? yMoves[amount - 1].toLowerCase()
                            : yMoves[amount - 1].toUpperCase());
        } else if (Math.abs(axis.getZ()) == Rotate.Z_AXIS.getZ()) {
            return upper ? zMoves[amount - 1]
                    : (CAPS.contains(zMoves[amount - 1]) ? zMoves[amount - 1].toLowerCase()
                            : zMoves[amount - 1].toUpperCase());
        } else {
            return null;
        }
    }

    /**
     * Rotate the given cube front clockwise.
     *
     * @param cube the cube to be rotated
     */
    public static void frontClockwise(Cube cube) {
        if (animating)
            return;
        animating = true;
        cube.rotateZ(0, 1, animation);
    }

    /**
     * Rotate the given cube right clockwise.
     *
     * @param cube the cube to be rotated
     */
    public static void rightClockwise(Cube cube) {
        if (animating)
            return;
        animating = true;
        cube.rotateX(Cube.cubeSize - 1, 1, animation);
    }

    /**
     * Rotate the given cube up clockwise.
     *
     * @param cube the cube to be rotated
     */
    public static void upClockwise(Cube cube) {
        if (animating)
            return;
        animating = true;
        cube.rotateY(0, -1, animation);
    }

    /**
     * Rotate the given cube left clockwise.
     *
     * @param cube the cube to be rotated
     */
    public static void leftClockwise(Cube cube) {
        if (animating)
            return;
        animating = true;
        cube.rotateX(0, -1, animation);
    }

    /**
     * Rotate the given cube back clockwise.
     *
     * @param cube the cube to be rotated
     */
    public static void backClockwise(Cube cube) {
        if (animating)
            return;
        animating = true;
        cube.rotateZ(Cube.cubeSize - 1, -1, animation);
    }

    /**
     * Rotate the given cube down clockwise.
     *
     * @param cube the cube to be rotated
     */
    public static void downClockwise(Cube cube) {
        if (animating)
            return;
        animating = true;
        cube.rotateY(Cube.cubeSize - 1, 1, animation);
    }

    /**
     * Rotate the given cube middle clockwise.
     *
     * @param cube the cube to be rotated
     */
    public static void middleClockwise(Cube cube) {
        if (animating)
            return;
        animating = true;
        cube.rotateX(Cube.cubeSize / 2, -1, animation);
    }

    /**
     * Rotate the given cube equator clockwise.
     *
     * @param cube the cube to be rotated
     */
    public static void equatorClockwise(Cube cube) {
        if (animating)
            return;
        animating = true;
        cube.rotateY(Cube.cubeSize / 2, 1, animation);
    }

    /**
     * Rotate the given cube standing counterclockwise.
     *
     * @param cube the cube to be rotated
     */
    public static void standingClockwise(Cube cube) {
        if (animating)
            return;
        animating = true;
        cube.rotateZ(Cube.cubeSize / 2, 1, animation);
    }

    /**
     * Rotate the given cube front counterclockwise.
     *
     * @param cube the cube to be rotated
     */
    public static void frontCounterClockwise(Cube cube) {
        if (animating)
            return;
        animating = true;
        cube.rotateZ(0, -1, animation);
    }

    /**
     * Rotate the given cube right counterclockwise.
     *
     * @param cube the cube to be rotated
     */
    public static void rightCounterClockwise(Cube cube) {
        if (animating)
            return;
        animating = true;
        cube.rotateX(Cube.cubeSize - 1, -1, animation);
    }

    /**
     * Rotate the given cube up counterclockwise.
     *
     * @param cube the cube to be rotated
     */
    public static void upCounterClockwise(Cube cube) {
        if (animating)
            return;
        animating = true;
        cube.rotateY(0, 1, animation);
    }

    /**
     * Rotate the given cube left counterclockwise.
     *
     * @param cube the cube to be rotated
     */
    public static void leftCounterClockwise(Cube cube) {
        if (animating)
            return;
        animating = true;
        cube.rotateX(0, 1, animation);
    }

    /**
     * Rotate the given cube back counterclockwise.
     *
     * @param cube the cube to be rotated
     */
    public static void backCounterClockwise(Cube cube) {
        if (animating)
            return;
        animating = true;
        cube.rotateZ(Cube.cubeSize - 1, 1, animation);
    }

    /**
     * Rotate the given cube down counterclockwise.
     *
     * @param cube the cube to be rotated
     */
    public static void downCounterClockwise(Cube cube) {
        if (animating)
            return;
        animating = true;
        cube.rotateY(Cube.cubeSize - 1, -1, animation);
    }

    /**
     * Rotate the given cube middle counterclockwise.
     *
     * @param cube the cube to be rotated
     */
    public static void middleCounterClockwise(Cube cube) {
        if (animating)
            return;
        animating = true;
        cube.rotateX(Cube.cubeSize / 2, 1, animation);
    }

    /**
     * Rotate the given cube equator counterclockwise.
     *
     * @param cube the cube to be rotated
     */
    public static void equatorCounterClockwise(Cube cube) {
        if (animating)
            return;
        animating = true;
        cube.rotateY(Cube.cubeSize / 2, -1, animation);
    }

    /**
     * Rotate the given cube standing counterclockwise.
     *
     * @param cube the cube to be rotated
     */
    public static void standingCounterClockwise(Cube cube) {
        if (animating)
            return;
        animating = true;
        cube.rotateZ(Cube.cubeSize / 2, -1, animation);
    }
}
